Project Title: P3 - cflow



Group: G33
NAME1: Catarina Correia, 	NR1: up201405765, GRADE1: 20, CONTRIBUTION1 33%
NAME2: Diogo Duque, 		NR2: up201406274, GRADE2: 20, CONTRIBUTION2 33%
NAME3: Jo√£o Silva, 			NR3: up201405490, GRADE3: 20, CONTRIBUTION3 33%


SUMMARY:
A tool to generate an automaton to check if the program execution control flow is according to the one specified as a regular expression. The tool parses the regular expression and generates the code to implement the automaton. The tool assumes that the code of the program has comments at the beginning of every BasicBlock, assigning the BasicBlock an ID. The automaton generated by the tool consists in a Java class that receives the info (BasicBlock id) from the instrumented points and processes it accordingly.


EXECUTE:
0. If necessary, clone the project using "git clone https://github.com/DiogoDuque/COMP-FEUP.git".
1. Enter the root directory of the project and run cflow to generate the DFA parser for a regex. Ex: "./cflow "A(BCE|BDE)+F" examples/1/input examples/1/output"
2. Go to the root folder of the example and execute the "run" script to process the program through the tool. Ex: "cd examples/1/; ./run".
3. You can already see in the result in the Terminal. However, if you want to see more information, do "firefox html/index.html".


DEALING WITH SYNTACTIC ERRORS:
Everytime a syntactic error happens, an exception is thrown showing what the problem was. Ex: if the problem was in the regular expression (ex: *abc?), the exception shows the "wrong symbol" (in this case, the first "*") and symbols that would be correct instead of it.


SEMANTIC ANALYSIS:
Semantical errors are impossible in our "parsing language", so we didn't implement semantic analysis.


CODE GENERATION: (when applicable, describe how the code generation of your tool works and identify the possible problems your tool has regarding code generation.)
Lorem ipsum


OVERVIEW:
In our approach to this problem, we first started by defining the grammar for the regular expressions, which accepts subsets of the PCRE format. If the regex is not accepted, the program is immediatly stopped. After the regex is accepted, we get the corresponding AST. After that, the AST is parsed into an epsilon-NFA using the "Thompson's Construction", which is later transformed into a DFA using the "Powerset Construction" (for performance and simplification purposes, or else the tool could become slow and too complex when running the tool with the program). The program is then run (with modifications for going through the DFA) to check if it is according to the original regex or not.
While we were developing, we used the GraphStream library for visualizing the automatons as graphs, as it helped us to visualize our progress and made debugging easier. However, it the user still wants to see the graphs (either for the NFA or DFA), it would just need to uncomment the 2 "display()" calls on CFlow's "main()". We also used Kadabra during the last part of the project for running the BasicBlocks through the DFA during the execution of the program.

TESTSUITE AND TEST INFRASTRUCTURE:
With our testsuite (containing 5 tests), we wanted to test every pattern that could appear in our regular expressions and in the testing programs.
Regarding regular expressions, we made an effort to include as much variability as possible. We used all the quantifiers ('?', '+' and '*'), whether they were after a character or a block, blocks inside blocks, alternation, etc. We used all these in simple and complicated ways alike.
As for code, we also made simple and complicated tests. We used 'for' and 'while' loops (sometimes chained in a row), 'if's and 'else's, many methods and even many files.

TASK DISTRIBUTION:
Our work was very distributed, so we all worked on everything.


PROS:
The tool does not appear to have any troubling bugs, errors or incomplete features, which is an important step for achieving stability and completeness. It also ends in a DFA run alongside the program, which causes negligible impact on performance during the program's execution.


CONS:
Does not support a large number of states since each state can only be represented by a letter. This means that a DFA can only have up to 54 states, since it's the number of letters in the alphabet (lowercase and uppercase).
